<!DOCTYPE html>
<html>
	<head>
		<title>Ganwalk II - Experiência II</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<!-- A biblioteca dat.GUI foi removida -->
		<!-- Importa as fontes Inter e Astloch do Google Fonts -->
    	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
		<link href="https://fonts.googleapis.com/css2?family=Astloch:wght@400;700&display=swap" rel="stylesheet">
		<style>
			:root {
				--control-bg: rgba(0, 0, 0, 0.8);
				--border-color: rgba(255, 255, 255, 0.2);
				--shadow-color: rgba(255, 255, 255, 0.15);
				--text-color: #ccc;
				--highlight-color: #fff;
			}
			html, body {
				width: 100%;
				height: 100%;
				margin: 0;
				padding: 0;
				overflow: hidden;
			}
			body {
				background-color: #000;
				font-family: 'Inter', sans-serif;
				color: var(--text-color);
			}
			video, #hidden-canvas {
				display: none;
			}
			#output-canvas {
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				display: block;
			}
			
			/* --- TELA DE INÍCIO --- */
			#start-screen {
				position: absolute;
				top: 0;
				left: 0;
				width: 100vw;
				height: 100vh;
				background-color: #000;
				display: flex;
				flex-direction: column;
				justify-content: center;
				align-items: center;
				z-index: 200;
				transition: opacity 1.5s ease;
				text-align: center;
				/* ALTERADO: Começa invisível para esperar a fonte carregar */
				opacity: 0;
				pointer-events: none;
			}
			/* ADICIONADO: Classe para tornar a tela visível após o carregamento da fonte */
			#start-screen.visible {
				opacity: 1;
				pointer-events: auto;
			}
			#start-screen.hidden {
				opacity: 0;
				pointer-events: none;
			}
			#ganwalk-text {
				font-family: 'Astloch', cursive;
				font-weight: 700;
				letter-spacing: -0.02em;
				font-size: 10vw;
				color: #fff;
				text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6);
			}
			#click-to-start-text {
				font-size: 1.5rem;
				color: #fff;
				cursor: pointer;
				transition: color 0.3s ease;
			}
			#click-to-start-text:hover {
				color: #ccc;
			}
			.faça-glow {
				text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff;
				animation: faça-flicker 2s infinite alternate;
			}
			@keyframes faça-flicker {
				0%, 100% { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #fff; }
				50% { text-shadow: 0 0 2px #fff, 0 0 5px #fff, 0 0 10px #fff; }
			}


			/* --- NOVA INTERFACE PERSONALIZADA --- */

			/* ADICIONADO: Esconde os controlos durante o ecrã de início */
			body.loading #controls-bar,
			body.loading #toggle-button,
			body.loading #create-prompt-text {
				opacity: 0;
				pointer-events: none;
			}

			#toggle-button {
				position: absolute;
				bottom: 20px; /* Posição fixa no fundo */
				left: 50%;
				transform: translateX(-50%);
				width: 50px;
				height: 50px;
				border-radius: 50%;
				background: var(--control-bg);
				border: 1px solid var(--border-color);
				box-shadow: 0 0 20px rgba(255, 255, 255, 0.15); /* Sombra/brilho branco */
				display: flex;
				align-items: center;
				justify-content: center;
				cursor: pointer;
				pointer-events: all;
				transition: background-color 0.2s, opacity 0.5s ease;
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
				z-index: 101; /* Fica por cima do menu */
			}
			#toggle-button:hover {
				background: rgba(255, 255, 255, 0.1);
			}

			#controls-bar {
				position: absolute;
				bottom: 85px; /* Posição acima do botão */
				left: 50%;
				transform: translateX(-50%);
				background: var(--control-bg);
				backdrop-filter: blur(10px);
				-webkit-backdrop-filter: blur(10px);
				border: 1px solid var(--border-color);
				box-shadow: 0 0 30px rgba(255, 255, 255, 0.15); /* Sombra/brilho branco */
				width: 90vw;
				max-width: 800px;
				padding: 15px 25px;
				transition: opacity 0.4s ease-in-out, transform 0.4s ease-in-out;
				pointer-events: all;
				border-radius: 8px; /* Cantos arredondados */
				z-index: 100;
				box-sizing: border-box;
			}

			/* Lógica de expandir/recolher */
			#controls-bar:not(.expanded) {
				opacity: 0;
				transform: translateX(-50%) translateY(20px);
				pointer-events: none;
			}

			#toggle-arrow {
				fill: var(--highlight-color);
				width: 24px;
				height: 24px;
				transition: transform 0.4s ease-in-out;
			}

			/* A rotação da seta depende se o menu está expandido */
			#controls-bar.expanded ~ #toggle-button #toggle-arrow {
				transform: rotate(180deg);
			}


			.controls-grid {
				display: grid;
				grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
				gap: 20px;
			}

			.control-group {
				display: flex;
				flex-direction: column;
				gap: 8px;
			}
			.control-group label {
				font-size: 12px;
			}
			.control-row {
				display: flex;
				align-items: center;
				justify-content: space-between;
			}
			.control-row label {
				flex-grow: 1;
			}

			/* Estilos para inputs */
			input[type="range"], input[type="text"], select, button {
				background: #111;
				border: 1px solid #444;
				color: var(--highlight-color);
				padding: 8px;
				font-family: 'Inter', sans-serif;
				width: 100%;
				box-sizing: border-box;
				border-radius: 4px;
			}
			
			button {
				cursor: pointer;
				transition: background-color 0.2s, border-color 0.2s;
			}
			button:hover {
				background: #222;
				border-color: #666;
			}

			input[type="color"] {
				-webkit-appearance: none;
				-moz-appearance: none;
				appearance: none;
				width: 40px;
				height: 25px;
				background-color: transparent;
				border: 1px solid #444;
				cursor: pointer;
				padding: 0;
				border-radius: 4px;
			}
			input[type="color"]::-webkit-color-swatch {
				border: none;
				border-radius: 3px;
			}
			input[type="color"]::-moz-color-swatch {
				border: none;
				border-radius: 3px;
			}
			input[type="checkbox"] {
				accent-color: var(--highlight-color);
				width: 18px;
				height: 18px;
			}

			input[type="range"] {
				-webkit-appearance: none;
				padding: 0;
				height: 12px;
				background: transparent;
			}
			input[type="range"]::-webkit-slider-runnable-track {
				width: 100%;
				height: 4px;
				background: #333;
				border-radius: 2px;
			}
			input[type="range"]::-webkit-slider-thumb {
				-webkit-appearance: none;
				height: 16px;
				width: 16px;
				background: var(--highlight-color);
				cursor: pointer;
				margin-top: -6px;
				border-radius: 50%;
			}

			.button-group {
				display: flex;
				gap: 10px;
			}

			/* NOVO: Estilos para o leitor de música */
			#music-player-container {
				display: flex;
				align-items: center;
				gap: 10px;
				background: #111;
				border: 1px solid #444;
				border-radius: 4px;
				padding: 5px;
			}

			#play-pause-music-btn {
				width: 40px;
				height: 40px;
				padding: 0;
				flex-shrink: 0;
				display: flex;
				align-items: center;
				justify-content: center;
			}

			#music-player-container svg {
				width: 24px;
				height: 24px;
				fill: var(--highlight-color);
			}

			.progress-container {
				display: flex;
				flex-direction: column;
				width: 100%;
				gap: 2px;
			}

			#music-progress-slider {
				width: 100%;
				margin: 0;
			}

			#music-time-display {
				font-size: 10px;
				color: var(--text-color);
				align-self: flex-end;
			}
			
			/* ALTERADO: Estilo para o título na interface */
			.interface-title {
				font-family: 'Astloch', cursive;
				font-weight: 700;
				text-align: left; /* Alinhado à esquerda */
				font-size: 2.5rem; /* Aumenta um pouco para destaque */
				color: var(--highlight-color);
				user-select: none;
				white-space: nowrap; /* Impede a quebra de linha */
				margin-top: auto; /* Empurra o título para o fundo da coluna flex */
				padding-top: 15px; /* Adiciona espaço acima do título */
				/* ADICIONADO: Efeito de brilho */
				text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(200, 200, 200, 0.6);
			}

			/* ADICIONADO: Estilo para a mensagem "Clique aqui e crie" */
			#create-prompt-text {
				position: absolute;
				bottom: 80px;
				left: 50%;
				transform: translateX(-50%);
				color: var(--text-color);
				font-size: 1rem;
				user-select: none;
				pointer-events: none;
				transition: opacity 0.4s ease-in-out;
			}

			#controls-bar.expanded ~ #create-prompt-text {
				opacity: 0;
			}
			
			/* ADICIONADO: Barra de rolagem subtil para a interface mobile */
			#controls-bar::-webkit-scrollbar {
				width: 6px;
			}

			#controls-bar::-webkit-scrollbar-track {
				background: transparent;
			}

			#controls-bar::-webkit-scrollbar-thumb {
				background-color: var(--border-color);
				border-radius: 10px;
			}


			/* --- MEDIA QUERIES PARA RESPONSIVIDADE --- */
			@media (max-width: 768px) {
				#controls-bar {
					width: 95vw; /* Ocupa mais a largura da tela */
					bottom: 75px; /* Sobe um pouco para dar espaço */
					padding: 15px; /* Menos preenchimento interno */
				}

				.controls-grid {
					grid-template-columns: 1fr; /* Força uma única coluna */
					gap: 25px; /* Aumenta o espaço entre os grupos de controlo */
				}
				
				/* NOVO: Torna a primeira coluna um container flex para reordenar o título */
				.control-group:first-of-type {
					display: flex;
					flex-direction: column;
				}

				/* ALTERADO: Move o título para o topo na versão mobile */
				.interface-title {
					order: -1; /* Move para o topo do seu container flex */
					text-align: center;
					margin-top: 0;
					margin-bottom: 25px; /* Adiciona espaço abaixo do título */
					padding-top: 0;
				}

				#toggle-button {
					width: 45px;
					height: 45px;
					bottom: 15px;
				}

				#ganwalk-text {
					font-size: 15vw; /* Aumenta um pouco em relação à largura para impacto */
				}

				#click-to-start-text {
					font-size: 1.2rem; /* Um pouco menor para caber melhor */
				}

				#create-prompt-text {
					bottom: 70px;
				}
			}

			@media (max-width: 480px) {
				#controls-bar {
					padding: 10px;
					max-height: 50vh; /* Evita que o menu ocupe a tela toda */
					overflow-y: auto; /* Permite rolar o menu se for muito grande */
				}
				.button-group {
					flex-direction: column; /* Empilha os botões */
				}
			}


		</style>
	</head>

	<body class="loading">
		<!-- TELA DE INÍCIO -->
		<div id="start-screen">
			<div id="ganwalk-text">GANWALK II</div>
			<div id="click-to-start-text">Clique, ouça e <span class="faça-glow">faça</span>.</div>
		</div>

		<!-- Canvas visível onde a arte ASCII será desenhada -->
		<canvas id="output-canvas"></canvas>

		<!-- Elementos de processamento ocultos -->
		<video id="video" autoplay playsinline muted></video>
		<canvas id="hidden-canvas"></canvas>
		<input type="file" id="video-upload" accept="video/*" style="display: none;">
		<audio id="background-audio" src="https://audio.jukehost.co.uk/WStLBcesFai1eER3Sqzzswbo9ISnqKWl" loop style="display:none;"></audio>
		
		<!-- NOVA INTERFACE DE CONTROLOS -->
		<div id="controls-bar">
			<div class="controls-grid">
				<!-- Coluna 1: Ações, Texto e Exportação -->
				<div class="control-group">
					<div class="button-group">
						<button id="clip-btn">Clipe Original</button>
						<button id="upload-btn">Carregar Vídeo</button>
						<button id="webcam-btn">Usar Webcam</button>
					</div>
					
					<div id="music-player-container">
						<button id="play-pause-music-btn">
							<svg id="play-icon" viewBox="0 0 24 24"><path d="M8 5v14l11-7z"/></svg>
							<svg id="pause-icon" style="display: none;" viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
						</button>
						<div class="progress-container">
							<input type="range" id="music-progress-slider" min="0" value="0" step="1">
							<span id="music-time-display">0:00 / 0:00</span>
						</div>
					</div>
					
					<!-- Separador Visual -->
					<hr style="border: none; border-top: 1px solid var(--border-color); margin: 8px 0;">

					<div class="button-group">
						<button id="export-image-btn">Exportar Imagem</button>
					</div>
					<!-- TÍTULO MOVIDO PARA A PRIMEIRA COLUNA -->
					<div class="interface-title">GANWALK II</div>
				</div>
				<!-- Coluna 2: Aparência -->
				<div class="control-group">
					<div class="control-row">
						<label for="bg-color-picker">Cor de Fundo</label>
						<input type="color" id="bg-color-picker">
					</div>
					<div class="control-row">
						<label for="bg-gradient-check">Fundo com Vídeo?</label>
						<input type="checkbox" id="bg-gradient-check">
					</div>
					<label for="bg-opacity-slider">Opacidade do Fundo</label>
					<input type="range" id="bg-opacity-slider" min="0" max="100" step="1">
					<div class="control-row">
						<label for="font-color1-picker">Cor da Fonte 1</label>
						<input type="color" id="font-color1-picker">
					</div>
					<div class="control-row">
						<label for="font-color2-picker">Cor da Fonte 2</label>
						<input type="color" id="font-color2-picker">
					</div>
				</div>
				<!-- Coluna 3: Parâmetros -->
				<div class="control-group">
					<label for="font-size-slider">Fator de Tamanho</label>
					<input type="range" id="font-size-slider" min="1" max="20" step="1">
					<label for="resolution-slider">Resolução</label>
					<input type="range" id="resolution-slider" min="10" max="150" step="1">
					<label for="threshold-slider">Limiar de Brilho</label>
					<input type="range" id="threshold-slider" min="0" max="255" step="1">
					<div class="control-row">
						<label for="invert-check">Inverter Cores?</label>
						<input type="checkbox" id="invert-check">
					</div>
					<label for="randomness-slider">Aleatoriedade</label>
					<input type="range" id="randomness-slider" min="0" max="20" step="1">
				</div>
			</div>
		</div>
		<!-- ADICIONADO: Mensagem para quando o menu está fechado -->
		<div id="create-prompt-text">Clique para <span class="faça-glow">criar</span>.</div>
		<div id="toggle-button">
			<svg id="toggle-arrow" viewBox="0 0 24 24">
				<path d="M7.41 15.41L12 10.83l4.59 4.58L18 14l-6-6-6 6z"/>
			</svg>
		</div>

		<!-- SCRIPT DO MP4-MUXER REMOVIDO -->
		
		<!-- SCRIPT PRINCIPAL DA APLICAÇÃO -->
		<script>
			// Lógica principal da aplicação
			const video = document.getElementById('video');
			const hiddenCanvas = document.getElementById('hidden-canvas');
			const hiddenCtx = hiddenCanvas.getContext('2d', { willReadFrequently: true });
			const outputCanvas = document.getElementById('output-canvas');
			const outputCtx = outputCanvas.getContext('2d');
			const videoUpload = document.getElementById('video-upload');
			const backgroundAudio = document.getElementById('background-audio');

			let stream;
			
			const settings = {
				backgroundColor: '#000000',
				bgGradient: false,
				bgSaturation: 72,
				fontColor: '#00ffff',
				fontColor2: '#ff7100',
				fontSizeFactor: 10,
				resolution: 35,
				threshold: 0,
				invert: false,
				randomness: 0
			};

			// ALTERADO: Ajusta a resolução inicial para dispositivos móveis para melhor performance.
			if (window.innerWidth <= 768) {
				settings.resolution = 20; 
			}
			
			const ORIGINAL_CLIP_URL = 'https://raw.githubusercontent.com/ganwalk/ganwalkascii/main/1002%20(1)%20(1).mp4';

			// --- Funções da Lógica Principal ---

			function getCharSet() {
				return "ganwalk";
			}
			
			function toAscii(grayData, width, height) {
				const charSet = getCharSet();
				let asciiLines = [];
				let userTextIndex = 0; 
				const finalGrayScales = new Uint8Array(grayData.length);

				for (let y = 0; y < height; y++) {
					let line = '';
					for (let x = 0; x < width; x++) {
						const pixelIndex = x + y * width;
						let gray = grayData[pixelIndex];

						if (settings.invert) gray = 255 - gray;
						finalGrayScales[pixelIndex] = gray;

						if (gray < settings.threshold) {
							line += ' ';
							continue;
						}

						let character;

						if (charSet && charSet.length > 0) {
							let finalIndex = userTextIndex;
							if (settings.randomness > 0) {
								const rand = Math.floor((Math.random() - 0.5) * settings.randomness);
								finalIndex += rand;
							}
							character = charSet[Math.abs(finalIndex) % charSet.length];
							userTextIndex++;
						} else {
							character = ' ';
						}
						
						line += character;
					}
					asciiLines.push(line);
				}
				return { asciiLines, finalGrayScales };
			}

			function hexToRgb(hex) {
				if (!hex) return { r: 0, g: 0, b: 0 };
				const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
				return result ? {
					r: parseInt(result[1], 16),
					g: parseInt(result[2], 16),
					b: parseInt(result[3], 16)
				} : { r: 0, g: 0, b: 0 };
			}

			function draw() {
				if (!video.videoWidth || (!video.srcObject && (video.paused || video.ended))) {
					requestAnimationFrame(draw);
					return;
				};
				
				outputCanvas.width = window.innerWidth;
				outputCanvas.height = window.innerHeight;
				
				const screenAspectRatio = outputCanvas.width / outputCanvas.height;
				let gridWidth, gridHeight;

				if (screenAspectRatio >= 1) {
					gridWidth = Math.floor(settings.resolution * 2 * screenAspectRatio);
					gridHeight = Math.floor(settings.resolution * 2);
				} else {
					gridWidth = Math.floor(settings.resolution * 2);
					gridHeight = Math.floor(settings.resolution * 2 / screenAspectRatio);
				}
				hiddenCanvas.width = gridWidth;
				hiddenCanvas.height = gridHeight;

    
				const videoAspectRatio = video.videoWidth / video.videoHeight;
    
				const gridAspectRatio = gridWidth / gridHeight; 
    
    
				let sWidth, sHeight, sx, sy;
    
    
				if (videoAspectRatio > gridAspectRatio) {
    
					sHeight = video.videoHeight;
    
					sWidth = sHeight * gridAspectRatio;
    
					sx = (video.videoWidth - sWidth) / 2;
    
					sy = 0;
    
				} else {
    
					sWidth = video.videoWidth;
    
					sHeight = sWidth / gridAspectRatio;
    
					sx = 0;
    
					sy = (video.videoHeight - sHeight) / 2;
    
				}

    
				hiddenCtx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, gridWidth, gridHeight);

				const imageData = hiddenCtx.getImageData(0, 0, gridWidth, gridHeight);
				const data = imageData.data;
				const grayScales = new Uint8Array(gridWidth * gridHeight);
				for (let i = 0; i < data.length; i += 4) {
					const r = data[i];
					const g = data[i + 1];
					const b = data[i + 2];
					const gray = 0.2126 * r + 0.7152 * g + 0.0722 * b;
					grayScales[i / 4] = gray;
				}

				const { asciiLines, finalGrayScales } = toAscii(grayScales, gridWidth, gridHeight);

				outputCtx.textAlign = 'center';
				outputCtx.textBaseline = 'middle';

				const cellWidth = outputCanvas.width / gridWidth;
				const cellHeight = outputCanvas.height / gridHeight;

				if (settings.bgGradient) {
					outputCtx.fillStyle = settings.backgroundColor;
					outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
					outputCtx.globalAlpha = settings.bgSaturation / 100;

					outputCtx.imageSmoothingEnabled = false;
					outputCtx.mozImageSmoothingEnabled = false;
					outputCtx.webkitImageSmoothingEnabled = false;
					outputCtx.msImageSmoothingEnabled = false;

					outputCtx.drawImage(hiddenCanvas, 0, 0, outputCanvas.width, outputCanvas.height);

					outputCtx.imageSmoothingEnabled = true;
					outputCtx.mozImageSmoothingEnabled = true;
					outputCtx.webkitImageSmoothingEnabled = true;
					outputCtx.msImageSmoothingEnabled = true;
					
					outputCtx.globalAlpha = 1.0;

				} else {
					outputCtx.fillStyle = settings.backgroundColor;
					outputCtx.fillRect(0, 0, outputCanvas.width, outputCanvas.height);
				}
				
				const color1RGB = hexToRgb(settings.fontColor);
				const color2RGB = hexToRgb(settings.fontColor2);

				for (let y = 0; y < gridHeight; y++) {
					for (let x = 0; x < gridWidth; x++) {
						const pixelIndex = x + y * gridWidth;
						const gray = finalGrayScales[pixelIndex];
						const character = asciiLines[y][x];

						if (character === ' ') continue;

						const factor = gray / 255;

						const r = Math.floor(color1RGB.r + (color2RGB.r - color1RGB.r) * factor);
						const g = Math.floor(color1RGB.g + (color2RGB.g - color1RGB.g) * factor);
						const b = Math.floor(color1RGB.b + (color2RGB.b - color1RGB.b) * factor);
						
						outputCtx.fillStyle = `rgb(${r},${g},${b})`;

						const charSize = factor * cellHeight * (settings.fontSizeFactor / 5.0);

						if (charSize < 1) continue;

						outputCtx.font = `${charSize}px monospace`;
						
						const cellCenterX = x * cellWidth + cellWidth / 2;
						const cellCenterY = y * cellHeight + cellHeight / 2;
						
						outputCtx.fillText(character, cellCenterX, cellCenterY);
					}
				}
				
				requestAnimationFrame(draw);
			}
			
			// --- Funções Auxiliares ---
			function setupOriginalClip() {
				if (stream) {
					stream.getTracks().forEach(track => track.stop());
					stream = null;
				}
				video.srcObject = null;
				video.src = ORIGINAL_CLIP_URL;
				video.crossOrigin = "anonymous";
				video.loop = true;

				video.onerror = () => {
					console.error("Erro ao carregar o vídeo. Verifique o URL e as permissões de CORS do servidor.");
				};

				const playPromise = video.play();
				if (playPromise !== undefined) {
					playPromise.catch(error => {
						console.error("A reprodução automática do vídeo foi impedida:", error);
						video.oncanplay = () => video.play();
					});
				}
			}
			
			async function setupWebcam() {
				video.src = '';
				try {
					if (stream) {
						stream.getTracks().forEach(track => track.stop());
					}
					stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
					video.srcObject = stream;
					video.loop = false;
					video.oncanplay = () => video.play();
				} catch (err) {
					console.error("Erro ao aceder à câmara: ", err);
				}
			}

			function handleVideoUpload(event) {
				video.src = '';
				const file = event.target.files[0];
				if (file) {
					if (stream) {
						stream.getTracks().forEach(track => track.stop());
						stream = null;
					}
					video.srcObject = null;
					video.src = URL.createObjectURL(file);
					video.loop = true;
					video.oncanplay = () => video.play();
				}
			}

			function exportImage() {
				const link = document.createElement('a');
				link.download = 'ascii-image.png';
				link.href = outputCanvas.toDataURL('image/png');
				link.click();
			}

			// --- INICIALIZAÇÃO E EVENTOS DA NOVA INTERFACE ---
			document.addEventListener('DOMContentLoaded', () => {
				const startScreen = document.getElementById('start-screen');
				const clickToStartText = document.getElementById('click-to-start-text');
				
				document.fonts.ready.then(() => {
					startScreen.classList.add('visible');
				});

				clickToStartText.addEventListener('click', async () => {
					startScreen.classList.add('hidden');
					document.body.classList.remove('loading'); // Mostra os controlos
					try {
						await backgroundAudio.play();
					} catch(err) {
						console.error("Falha ao reproduzir áudio:", err);
					}
				});
				
				const controlsBar = document.getElementById('controls-bar');
				const toggleButton = document.getElementById('toggle-button');
				
				const clipBtn = document.getElementById('clip-btn');
				const uploadBtn = document.getElementById('upload-btn');
				const webcamBtn = document.getElementById('webcam-btn');
				const exportImageBtn = document.getElementById('export-image-btn');

				const playPauseMusicBtn = document.getElementById('play-pause-music-btn');
				const musicProgressSlider = document.getElementById('music-progress-slider');
				const musicTimeDisplay = document.getElementById('music-time-display');
				const playIcon = document.getElementById('play-icon');
				const pauseIcon = document.getElementById('pause-icon');

				const bgColorPicker = document.getElementById('bg-color-picker');
				const bgGradientCheck = document.getElementById('bg-gradient-check');
				const bgOpacitySlider = document.getElementById('bg-opacity-slider');
				const fontColor1Picker = document.getElementById('font-color1-picker');
				const fontColor2Picker = document.getElementById('font-color2-picker');
				const fontSizeSlider = document.getElementById('font-size-slider');
				const resolutionSlider = document.getElementById('resolution-slider');
				const thresholdSlider = document.getElementById('threshold-slider');
				const invertCheck = document.getElementById('invert-check');
				const randomnessSlider = document.getElementById('randomness-slider');

				toggleButton.addEventListener('click', () => {
					controlsBar.classList.toggle('expanded');
				});
				
				clipBtn.addEventListener('click', setupOriginalClip);
				uploadBtn.addEventListener('click', () => videoUpload.click());
				webcamBtn.addEventListener('click', setupWebcam);
				
				playPauseMusicBtn.addEventListener('click', () => {
					// ALTERADO: Sincroniza o vídeo com a música
					const isOriginalClip = video.currentSrc === ORIGINAL_CLIP_URL;

					if (backgroundAudio.paused) {
						backgroundAudio.play();
						if (isOriginalClip) {
							video.play();
						}
					} else {
						backgroundAudio.pause();
						if (isOriginalClip) {
							video.pause();
						}
					}
				});

				backgroundAudio.addEventListener('play', () => {
					playIcon.style.display = 'none';
					pauseIcon.style.display = 'block';
				});

				backgroundAudio.addEventListener('pause', () => {
					playIcon.style.display = 'block';
					pauseIcon.style.display = 'none';
				});
				
				const formatTime = (seconds) => {
					const minutes = Math.floor(seconds / 60);
					const remainingSeconds = Math.floor(seconds % 60);
					return `${minutes}:${remainingSeconds < 10 ? '0' : ''}${remainingSeconds}`;
				}

				const updateMusicTime = () => {
					if (isNaN(backgroundAudio.duration)) return;
					const currentTime = formatTime(backgroundAudio.currentTime);
					const duration = formatTime(backgroundAudio.duration);
					musicTimeDisplay.textContent = `${currentTime} / ${duration}`;
					musicProgressSlider.value = backgroundAudio.currentTime;
				};
				
				backgroundAudio.addEventListener('loadedmetadata', () => {
					musicProgressSlider.max = backgroundAudio.duration;
					updateMusicTime();
				});

				backgroundAudio.addEventListener('timeupdate', updateMusicTime);

				musicProgressSlider.addEventListener('input', (e) => {
					backgroundAudio.currentTime = e.target.value;
				});

				exportImageBtn.addEventListener('click', exportImage);

				bgColorPicker.addEventListener('input', (e) => settings.backgroundColor = e.target.value);
				bgGradientCheck.addEventListener('change', (e) => settings.bgGradient = e.target.checked);
				bgOpacitySlider.addEventListener('input', (e) => settings.bgSaturation = e.target.value);
				fontColor1Picker.addEventListener('input', (e) => settings.fontColor = e.target.value);
				fontColor2Picker.addEventListener('input', (e) => settings.fontColor2 = e.target.value);
				fontSizeSlider.addEventListener('input', (e) => settings.fontSizeFactor = e.target.value);
				resolutionSlider.addEventListener('input', (e) => settings.resolution = e.target.value);
				thresholdSlider.addEventListener('input', (e) => settings.threshold = e.target.value);
				invertCheck.addEventListener('change', (e) => settings.invert = e.target.checked);
				randomnessSlider.addEventListener('input', (e) => settings.randomness = e.target.value);

				bgColorPicker.value = settings.backgroundColor;
				bgGradientCheck.checked = settings.bgGradient;
				bgOpacitySlider.value = settings.bgSaturation;
				fontColor1Picker.value = settings.fontColor;
				fontColor2Picker.value = settings.fontColor2;
				fontSizeSlider.value = settings.fontSizeFactor;
				resolutionSlider.value = settings.resolution;
				thresholdSlider.value = settings.threshold;
				invertCheck.checked = settings.invert;
				randomnessSlider.value = settings.randomness;

				videoUpload.addEventListener('change', handleVideoUpload);
				window.addEventListener('resize', draw, false);
				
				clickToStartText.addEventListener('click', () => {
					setupOriginalClip();
					draw();
				}, { once: true });
			});
		</script>
	</body>
</html>



